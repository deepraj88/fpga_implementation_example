// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2018.2
// Copyright (C) 1986-2018 Xilinx, Inc. All Rights Reserved.
// 
// ==============================================================

 `timescale 1ns/1ps

module rotate_fpga
(
    input CLK100MHZ       , 
    input BTNC            ,
    input BTNU            ,
    input BTNL            ,
    input BTNR            ,
    input BTND            ,
    //output [15:0] LED     ,
    input UART_TXD_IN     ,
    output UART_RXD_OUT   
  );

wire CLK100M;
wire CPU_RESETN;

assign CLK100M = CLK100MHZ;
assign CPU_RESETN = !BTNC;

reg [31:0] a;
reg [31:0] b;
wire [31:0] c;
wire vld;
wire tx_vld;
wire [07:0] o_rx_out;
reg [07:0] tx_data;
wire o_frame_error;
wire uart_busy;
reg uart_busy_d;

reg [02:0] rx_counter;
reg [01:0] tx_counter;
wire tx_start;
reg [15:0] delay_counter;

reg [31:0] a_d;
reg [31:0] b_d;

uart_wrapper2 u_uart_wrapper2(
    .CLK           (CLK100M       ),
    .CPU_RESET     (!CPU_RESETN   ),
    .USB_UART_TX   (UART_TXD_IN   ),
    .USB_UART_RX2   (UART_RXD_OUT  ),
    .O_RX_OUT2      (o_rx_out      ), 
    .O_RX_VLD2      (vld      ),
    .O_FRAME_ERROR2 (o_frame_error ),
    .I_TX_DATA     (tx_data ),
    .I_TX_START    (tx_vld),
    .O_BUSY2        (uart_busy     )
    );

/*
uart_wrapper u_uart_wrapper(
    .CLK           (CLK100M       ),
    .CPU_RESET     (!CPU_RESETN   ),
    .USB_UART_TX   (UART_TXD_IN   ),
    .USB_UART_RX   (UART_RXD_OUT  ),
    .O_RX_OUT      (o_rx_out      ), 
    .O_RX_VLD      (vld      ),
    .O_FRAME_ERROR (o_frame_error ),
    .I_TX_DATA     (tx_data ),
    .I_TX_START    (tx_vld),
    .O_BUSY        (uart_busy     )
    );
*/
always @(*) begin
case (rx_counter) 
    0 : a[31:24] = o_rx_out;
    1 : a[23:16] = o_rx_out;
    2 : a[15:08] = o_rx_out;
    3 : a[07:00] = o_rx_out;
    4 : b[31:24] = o_rx_out;
    5 : b[23:16] = o_rx_out;
    6 : b[15:08] = o_rx_out;
    7 : b[07:00] = o_rx_out;
endcase
end    

always @(posedge CLK100M or negedge CPU_RESETN) begin
   if(!CPU_RESETN) begin
        a_d <= 'd0;
        b_d <= 'd0;
        rx_counter <= 'd0;
   end else if(vld) begin
        a_d <= a;
        b_d <= b;
        rx_counter <= rx_counter+1;
   end
end

always @(posedge CLK100M or negedge CPU_RESETN) begin
   if(!CPU_RESETN) begin
        delay_counter <= 'hFFFF;
   end else if(vld) begin
        delay_counter <= 'h0000;
   end else if(delay_counter<'hFFFF) begin
        delay_counter <= delay_counter+1;
   end
end

assign tx_start = (delay_counter == 'hFFFE);

assign tx_vld = tx_start | (!uart_busy_d && tx_counter != 0);

always @(posedge CLK100M or negedge CPU_RESETN) begin
   if(!CPU_RESETN) begin
    uart_busy_d <= 'd3;
   end else begin
    uart_busy_d <= uart_busy;
   end
end

always @(*) begin
case (tx_counter) 
    0 : tx_data = c[31:24];
    1 : tx_data = c[23:16];
    2 : tx_data = c[15:08];
    3 : tx_data = c[07:00];
endcase
end    

always @(posedge CLK100M or negedge CPU_RESETN) begin
   if(!CPU_RESETN) begin
        tx_counter <= 'd0;
   end else if(tx_vld) begin
        tx_counter <= tx_counter + 1;
   end
end
/*
leftrotate u_left_rotate(
    .a              (a_d),
    .b              (b_d),
    .outx           (c)
);
 */
endmodule
